"""nAnalysis orchestrator for coordinating fixture analysis.n"""nnimport asyncionimport loggingnfrom datetime import datetimenfrom typing import Optionalnfrom ...domain.entities import Fixture, AnalysisResult, ConsensusAnalysis, ErrorAnalysis, ComparisonAnalysisnfrom ...application.ports import DataPort, AnalysisPort, NLPPort, OutputPortnfrom ...domain.exceptions import FixtureNotFoundError, AnalysisErrornnlogger = logging.getLogger(__name__)nnnclass AnalysisOrchestrator:n    """n    Orchestrator for coordinating fixture analysis operations.n    n    This class coordinates the execution of analysis workflows,n    managing the flow between data access, analysis, NLP, and output ports.n    """n    n    def __init__(self, data_port: DataPort, analysis_port: AnalysisPort, n                 nlp_port: NLPPort, output_port: OutputPort):n        """n        Initialize the analysis orchestrator.n        n        Args:n            data_port: Port for data access operationsn            analysis_port: Port for analysis operationsn            nlp_port: Port for natural language processingn            output_port: Port for output generationn        """n        self.data_port = data_portn        self.analysis_port = analysis_portn        self.nlp_port = nlp_portn        self.output_port = output_portn        logger.info("Analysis Orchestrator initialized")n    n    async def analyze_fixture(self, fixture_id: str) -> AnalysisResult:n        """n        Perform comprehensive analysis of a fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            AnalysisResult object with complete analysisn        n        Raises:n            FixtureNotFoundError: If fixture is not foundn            AnalysisError: If analysis failsn        """n        try:n            logger.info(f"Starting comprehensive analysis for fixture: {fixture_id}")n            n            # Step 1: Retrieve fixture datan            logger.debug(f"Retrieving data for fixture: {fixture_id}")n            fixture = await self.data_port.get_fixture_data(fixture_id)n            n            if not fixture:n                raise FixtureNotFoundError(f"Fixture {fixture_id} not found")n            n            # Step 2: Perform parallel analysisn            logger.debug(f"Performing parallel analysis for fixture: {fixture_id}")n            consensus_task = self.analysis_port.analyze_consensus(fixture)n            error_task = self.analysis_port.detect_errors(fixture)n            comparison_task = self.analysis_port.compare_provider_system(fixture)n            n            # Execute all analysis tasks concurrentlyn            consensus_analysis, error_analysis, comparison_analysis = await asyncio.gather(n                consensus_task, error_task, comparison_taskn            )n            n            # Step 3: Generate summaryn            logger.debug(f"Generating summary for fixture: {fixture_id}")n            summary = await self.nlp_port.generate_summary(AnalysisResult(n                fixture_id=fixture_id,n                analysis_timestamp=datetime.utcnow(),n                fixture=fixture,n                consensus_analysis=consensus_analysis,n                error_analysis=error_analysis,n                comparison_analysis=comparison_analysis,n                summary=""n            ))n            n            # Step 4: Create final analysis resultn            analysis_result = AnalysisResult(n                fixture_id=fixture_id,n                analysis_timestamp=datetime.utcnow(),n                fixture=fixture,n                consensus_analysis=consensus_analysis,n                error_analysis=error_analysis,n                comparison_analysis=comparison_analysis,n                summary=summaryn            )n            n            logger.info(f"Comprehensive analysis completed for fixture: {fixture_id}")n            return analysis_resultn            n        except FixtureNotFoundError:n            logger.error(f"Fixture not found: {fixture_id}")n            raisen        except Exception as e:n            logger.error(f"Analysis failed for fixture {fixture_id}: {e}")n            raise AnalysisError(f"Analysis failed: {e}")n    n    async def analyze_multiple_fixtures(self, fixture_ids: list[str]) -> list[AnalysisResult]:n        """n        Analyze multiple fixtures concurrently.n        n        Args:n            fixture_ids: List of fixture IDs to analyzen        n        Returns:n            List of AnalysisResult objectsn        """n        try:n            logger.info(f"Starting analysis for {len(fixture_ids)} fixtures")n            n            # Create analysis tasks for all fixturesn            tasks = [self.analyze_fixture(fixture_id) for fixture_id in fixture_ids]n            n            # Execute all tasks concurrentlyn            results = await asyncio.gather(*tasks, return_exceptions=True)n            n            # Filter out exceptions and log themn            analysis_results = []n            for i, result in enumerate(results):n                if isinstance(result, Exception):n                    logger.error(f"Analysis failed for fixture {fixture_ids[i]}: {result}")n                else:n                    analysis_results.append(result)n            n            logger.info(f"Completed analysis for {len(analysis_results)} fixtures")n            return analysis_resultsn            n        except Exception as e:n            logger.error(f"Multiple fixture analysis failed: {e}")n            raise AnalysisError(f"Multiple fixture analysis failed: {e}")n    n    async def get_analysis_status(self, fixture_id: str) -> dict:n        """n        Get the current analysis status for a fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            Dictionary with analysis status informationn        """n        try:n            # Check if fixture existsn            fixture = await self.data_port.get_fixture_data(fixture_id)n            n            return {n                "fixture_id": fixture_id,n                "status": "available",n                "incidents_count": len(fixture.incidents),n                "decisions_count": len(fixture.decisions),n                "providers_count": len(fixture.providers),n                "last_updated": datetime.utcnow().isoformat()n            }n            n        except FixtureNotFoundError:n            return {n                "fixture_id": fixture_id,n                "status": "not_found",n                "last_updated": datetime.utcnow().isoformat()n            }n        except Exception as e:n            logger.error(f"Error getting analysis status for fixture {fixture_id}: {e}")n            return {n                "fixture_id": fixture_id,n                "status": "error",n                "error": str(e),n                "last_updated": datetime.utcnow().isoformat()n            }
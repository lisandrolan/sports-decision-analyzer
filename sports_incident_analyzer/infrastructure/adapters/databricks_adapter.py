"""nDatabricks adapter for data access operations.n"""nnimport asyncionimport loggingnfrom typing import List, Dict, Any, Optionalnfrom datetime import datetimenimport pandas as pdnfrom databricks import sqlnfrom databricks.sql import connectnnfrom ...core.application.ports.data_port import DataPortnfrom ...core.domain.entities import Fixture, Incident, Decision, Provider, IncidentType, IncidentStatus, DecisionType, DecisionStatus, ProviderStatus, ProviderReliabilitynfrom ...core.domain.exceptions import FixtureNotFoundError, DataAccessErrornnlogger = logging.getLogger(__name__)nnnclass DatabricksAdapter(DataPort):n    """n    Adapter for accessing data from Databricks.n    n    This adapter implements the DataPort interface to providen    access to fixture data stored in Databricks tables.n    """n    n    def __init__(self, host: str, token: str, catalog: str, schema: str):n        """n        Initialize the Databricks adapter.n        n        Args:n            host: Databricks workspace hostn            token: Access token for Databricksn            catalog: Catalog namen            schema: Schema namen        """n        self.host = hostn        self.token = tokenn        self.catalog = catalogn        self.schema = scheman        self.connection = Nonen        n    async def _get_connection(self):n        """Get or create a connection to Databricks."""n        if self.connection is None:n            try:n                self.connection = connect(n                    server_hostname=self.host,n                    http_path="/sql/1.0/warehouses/your-warehouse-id",n                    access_token=self.tokenn                )n                logger.info("Successfully connected to Databricks")n            except Exception as e:n                logger.error(f"Failed to connect to Databricks: {e}")n                raise DataAccessError(f"Connection failed: {e}")n        return self.connectionn    n    async def get_fixture_data(self, fixture_id: str) -> Fixture:n        """n        Retrieve complete fixture data including all related entities.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            Fixture object with all related data loadedn        n        Raises:n            FixtureNotFoundError: If fixture is not foundn            DataAccessError: If there are issues accessing the datan        """n        try:n            # Get all related data concurrentlyn            incidents_task = self.get_incidents_by_fixture(fixture_id)n            decisions_task = self.get_decisions_by_fixture(fixture_id)n            providers_task = self.get_providers_by_fixture(fixture_id)n            n            incidents, decisions, providers = await asyncio.gather(n                incidents_task, decisions_task, providers_taskn            )n            n            # Create fixture object (basic info would come from a fixtures table)n            # For now, we'll create a basic fixture with the data we haven            fixture = Fixture(n                fixture_id=fixture_id,n                start_time=datetime.utcnow(),  # This should come from fixtures tablen                status="active"n            )n            n            # Add all related datan            for incident in incidents:n                fixture.add_incident(incident)n            for decision in decisions:n                fixture.add_decision(decision)n            for provider in providers:n                fixture.add_provider(provider)n            n            return fixturen            n        except Exception as e:n            logger.error(f"Error retrieving fixture data for {fixture_id}: {e}")n            raise DataAccessError(f"Failed to retrieve fixture data: {e}")n    n    async def get_incidents_by_fixture(self, fixture_id: str) -> List[Incident]:n        """n        Retrieve all incidents for a specific fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            List of incidents for the fixturen        """n        query = f"""n        SELECT * FROM {self.catalog}.{self.schema}.extractedn        WHERE fixture_id = '{fixture_id}'n        ORDER BY timestampn        """n        n        try:n            connection = await self._get_connection()n            with connection.cursor() as cursor:n                cursor.execute(query)n                results = cursor.fetchall()n                n            incidents = []n            for row in results:n                incident = Incident(n                    incident_id=row.incident_id,n                    fixture_id=row.fixture_id,n                    incident_type=IncidentType(row.incident_type),n                    timestamp=row.timestamp,n                    score=row.score,n                    provider_id=row.provider_id,n                    is_cancelled=row.is_cancelled,n                    status=IncidentStatus.CONFIRMED if not row.is_cancelled else IncidentStatus.CANCELLEDn                )n                incidents.append(incident)n            n            return incidentsn            n        except Exception as e:n            logger.error(f"Error retrieving incidents for fixture {fixture_id}: {e}")n            raise DataAccessError(f"Failed to retrieve incidents: {e}")n    n    async def get_decisions_by_fixture(self, fixture_id: str) -> List[Decision]:n        """n        Retrieve all decisions for a specific fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            List of decisions for the fixturen        """n        query = f"""n        SELECT * FROM {self.catalog}.{self.schema}.decision_resultn        WHERE fixture_id = '{fixture_id}'n        ORDER BY timestampn        """n        n        try:n            connection = await self._get_connection()n            with connection.cursor() as cursor:n                cursor.execute(query)n                results = cursor.fetchall()n                n            decisions = []n            for row in results:n                decision = Decision(n                    decision_id=row.decision_id,n                    fixture_id=row.fixture_id,n                    incident_type=row.incident_type,n                    decision_type=DecisionType(row.decision_type),n                    score=row.score,n                    consensus_providers=row.consensus_providers,n                    participating_providers=row.participating_providers,n                    timestamp=row.timestamp,n                    status=DecisionStatus.CONFIRMEDn                )n                decisions.append(decision)n            n            return decisionsn            n        except Exception as e:n            logger.error(f"Error retrieving decisions for fixture {fixture_id}: {e}")n            raise DataAccessError(f"Failed to retrieve decisions: {e}")n    n    async def get_providers_by_fixture(self, fixture_id: str) -> List[Provider]:n        """n        Retrieve all providers that participated in a fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            List of providers for the fixturen        """n        query = f"""n        SELECT DISTINCT provider_id, n               COUNT(*) as total_messages,n               MAX(timestamp) as last_seenn        FROM {self.catalog}.{self.schema}.rawn        WHERE fixture_id = '{fixture_id}'n        GROUP BY provider_idn        """n        n        try:n            connection = await self._get_connection()n            with connection.cursor() as cursor:n                cursor.execute(query)n                results = cursor.fetchall()n                n            providers = []n            for row in results:n                provider = Provider(n                    provider_id=row.provider_id,n                    name=f"Provider {row.provider_id}",n                    last_seen=row.last_seen,n                    total_messages=row.total_messages,n                    status=ProviderStatus.ACTIVEn                )n                providers.append(provider)n            n            return providersn            n        except Exception as e:n            logger.error(f"Error retrieving providers for fixture {fixture_id}: {e}")n            raise DataAccessError(f"Failed to retrieve providers: {e}")n    n    async def get_raw_messages_by_fixture(self, fixture_id: str) -> List[Dict[str, Any]]:n        """n        Retrieve raw messages from providers for a specific fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            List of raw message dictionariesn        """n        query = f"""n        SELECT * FROM {self.catalog}.{self.schema}.rawn        WHERE fixture_id = '{fixture_id}'n        ORDER BY timestampn        """n        n        try:n            connection = await self._get_connection()n            with connection.cursor() as cursor:n                cursor.execute(query)n                results = cursor.fetchall()n                n            messages = []n            for row in results:n                message = {n                    "provider_id": row.provider_id,n                    "score": row.score,n                    "status": row.status,n                    "is_cancelled": row.is_cancelled,n                    "timestamp": row.timestampn                }n                messages.append(message)n            n            return messagesn            n        except Exception as e:n            logger.error(f"Error retrieving raw messages for fixture {fixture_id}: {e}")n            raise DataAccessError(f"Failed to retrieve raw messages: {e}")n    n    async def get_extracted_incidents_by_fixture(self, fixture_id: str) -> List[Dict[str, Any]]:n        """n        Retrieve extracted incidents for a specific fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            List of extracted incident dictionariesn        """n        query = f"""n        SELECT * FROM {self.catalog}.{self.schema}.extractedn        WHERE fixture_id = '{fixture_id}'n        ORDER BY timestampn        """n        n        try:n            connection = await self._get_connection()n            with connection.cursor() as cursor:n                cursor.execute(query)n                results = cursor.fetchall()n                n            incidents = []n            for row in results:n                incident = {n                    "incident_id": row.incident_id,n                    "incident_type": row.incident_type,n                    "score": row.score,n                    "provider_id": row.provider_id,n                    "is_cancelled": row.is_cancelled,n                    "timestamp": row.timestampn                }n                incidents.append(incident)n            n            return incidentsn            n        except Exception as e:n            logger.error(f"Error retrieving extracted incidents for fixture {fixture_id}: {e}")n            raise DataAccessError(f"Failed to retrieve extracted incidents: {e}")n    n    async def get_decision_results_by_fixture(self, fixture_id: str) -> List[Dict[str, Any]]:n        """n        Retrieve decision results for a specific fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            List of decision result dictionariesn        """n        query = f"""n        SELECT * FROM {self.catalog}.{self.schema}.decision_resultn        WHERE fixture_id = '{fixture_id}'n        ORDER BY timestampn        """n        n        try:n            connection = await self._get_connection()n            with connection.cursor() as cursor:n                cursor.execute(query)n                results = cursor.fetchall()n                n            decisions = []n            for row in results:n                decision = {n                    "decision_id": row.decision_id,n                    "incident_type": row.incident_type,n                    "decision_type": row.decision_type,n                    "score": row.score,n                    "consensus_providers": row.consensus_providers,n                    "participating_providers": row.participating_providers,n                    "timestamp": row.timestampn                }n                decisions.append(decision)n            n            return decisionsn            n        except Exception as e:n            logger.error(f"Error retrieving decision results for fixture {fixture_id}: {e}")n            raise DataAccessError(f"Failed to retrieve decision results: {e}")n    n    async def close(self):n        """Close the Databricks connection."""n        if self.connection:n            self.connection.close()n            self.connection = Nonen            logger.info("Databricks connection closed")
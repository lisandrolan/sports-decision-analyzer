"""nMain agent class for the Sports Incident Analyzer.n"""nnimport asyncionimport loggingnfrom typing import Optional, Dict, Anynfrom datetime import datetimenfrom ..core.application.ports import DataPort, AnalysisPort, NLPPort, OutputPortnfrom ..core.domain.entities import AnalysisResult, Fixturenfrom ..core.domain.exceptions import SportsIncidentAnalyzerError, FixtureNotFoundErrornfrom ..core.application.orchestrators import AnalysisOrchestratornnlogger = logging.getLogger(__name__)nnnclass SportsIncidentAnalyzer:n    """n    Main agent class for analyzing sports incidents and decisions.n    n    This class provides the primary interface for analyzing fixturesn    and answering natural language questions about incidents.n    """n    n    def __init__(self, data_port: DataPort, analysis_port: AnalysisPort, n                 nlp_port: NLPPort, output_port: OutputPort):n        """n        Initialize the Sports Incident Analyzer.n        n        Args:n            data_port: Port for data access operationsn            analysis_port: Port for analysis operationsn            nlp_port: Port for natural language processingn            output_port: Port for output generationn        """n        self.data_port = data_portn        self.analysis_port = analysis_portn        self.nlp_port = nlp_portn        self.output_port = output_portn        self.orchestrator = AnalysisOrchestrator(n            data_port, analysis_port, nlp_port, output_portn        )n        logger.info("Sports Incident Analyzer initialized")n    n    async def analyze_fixture(self, fixture_id: str) -> AnalysisResult:n        """n        Analyze a specific fixture and return comprehensive results.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            AnalysisResult object with complete analysisn        n        Raises:n            FixtureNotFoundError: If fixture is not foundn            SportsIncidentAnalyzerError: If analysis failsn        """n        try:n            logger.info(f"Starting analysis for fixture: {fixture_id}")n            result = await self.orchestrator.analyze_fixture(fixture_id)n            logger.info(f"Analysis completed for fixture: {fixture_id}")n            return resultn        except FixtureNotFoundError:n            logger.error(f"Fixture not found: {fixture_id}")n            raisen        except Exception as e:n            logger.error(f"Analysis failed for fixture {fixture_id}: {e}")n            raise SportsIncidentAnalyzerError(f"Analysis failed: {e}")n    n    async def answer_question(self, question: str, fixture_id: str) -> str:n        """n        Answer a natural language question about a specific fixture.n        n        Args:n            question: Natural language questionn            fixture_id: Unique identifier for the fixturen        n        Returns:n            Natural language answer to the questionn        n        Raises:n            FixtureNotFoundError: If fixture is not foundn            SportsIncidentAnalyzerError: If question processing failsn        """n        try:n            logger.info(f"Processing question for fixture {fixture_id}: {question}")n            n            # Process the questionn            processed_question = await self.nlp_port.process_question(question)n            n            # Get fixture data if not already cachedn            fixture = await self.data_port.get_fixture_data(fixture_id)n            n            # Perform analysisn            consensus_analysis = await self.analysis_port.analyze_consensus(fixture)n            error_analysis = await self.analysis_port.detect_errors(fixture)n            comparison_analysis = await self.analysis_port.compare_provider_system(fixture)n            n            # Create analysis resultn            from ..core.domain.entities import ConsensusAnalysis, ErrorAnalysis, ComparisonAnalysisn            analysis_result = AnalysisResult(n                fixture_id=fixture_id,n                analysis_timestamp=datetime.utcnow(),n                fixture=fixture,n                consensus_analysis=consensus_analysis,n                error_analysis=error_analysis,n                comparison_analysis=comparison_analysis,n                summary=""  # Will be generated by NLP portn            )n            n            # Generate responsen            response = await self.nlp_port.generate_response(processed_question, analysis_result)n            n            logger.info(f"Question answered successfully for fixture {fixture_id}")n            return responsen            n        except FixtureNotFoundError:n            logger.error(f"Fixture not found: {fixture_id}")n            raisen        except Exception as e:n            logger.error(f"Question processing failed for fixture {fixture_id}: {e}")n            raise SportsIncidentAnalyzerError(f"Question processing failed: {e}")n    n    async def get_json_diagnostic(self, fixture_id: str) -> Dict[str, Any]:n        """n        Get a JSON diagnostic for a specific fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            Dictionary containing the JSON diagnosticn        """n        try:n            analysis_result = await self.analyze_fixture(fixture_id)n            return await self.output_port.generate_json_diagnostic(analysis_result)n        except Exception as e:n            logger.error(f"Failed to generate JSON diagnostic for fixture {fixture_id}: {e}")n            raise SportsIncidentAnalyzerError(f"JSON diagnostic generation failed: {e}")n    n    async def get_summary(self, fixture_id: str) -> str:n        """n        Get a natural language summary for a specific fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            Natural language summary stringn        """n        try:n            analysis_result = await self.analyze_fixture(fixture_id)n            return await self.output_port.generate_summary_report(analysis_result)n        except Exception as e:n            logger.error(f"Failed to generate summary for fixture {fixture_id}: {e}")n            raise SportsIncidentAnalyzerError(f"Summary generation failed: {e}")n    n    async def get_detailed_report(self, fixture_id: str) -> Dict[str, Any]:n        """n        Get a detailed report for a specific fixture.n        n        Args:n            fixture_id: Unique identifier for the fixturen        n        Returns:n            Dictionary containing the detailed reportn        """n        try:n            analysis_result = await self.analyze_fixture(fixture_id)n            return await self.output_port.generate_detailed_report(analysis_result)n        except Exception as e:n            logger.error(f"Failed to generate detailed report for fixture {fixture_id}: {e}")n            raise SportsIncidentAnalyzerError(f"Detailed report generation failed: {e}")n    n    async def close(self):n        """Close all connections and cleanup resources."""n        try:n            if hasattr(self.data_port, 'close'):n                await self.data_port.close()n            logger.info("Sports Incident Analyzer closed successfully")n        except Exception as e:n            logger.error(f"Error closing Sports Incident Analyzer: {e}")